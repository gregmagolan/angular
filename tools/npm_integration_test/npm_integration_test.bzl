# Copyright 2017 The Bazel Authors. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Npm integration testing
"""

load("//tools:windows_utils.bzl", "BATCH_RLOCATION_FUNCTION", "is_windows")

# Returns the manifest path of a file: `workspace/path/to/file`
def _to_manifest_path(ctx, file):
    if file.short_path.startswith("../"):
        # Strip the ../ from short_path to external repository
        return file.short_path[3:]
    else:
        # Add the repository name for short_path to local repository
        return ctx.workspace_name + "/" + file.short_path

def _npm_integration_test_impl(ctx):
    if len(ctx.files.test_files) == 0:
        fail("No files were found to run under integration testing.")

    if ctx.attr.debug:
        for f in ctx.files.test_files:
            if not f.is_source:
                fail("In debug mode, all test files must be source files.")

    commands = []
    for c in ctx.attr.commands:
        commands.append(ctx.expand_location(c, targets = ctx.attr.data))

    # pass --define vars to test; these are added to the environment using process.env().
    env_vars = {}
    for k in ctx.attr.configuration_env_vars:
        if k in ctx.var.keys():
            env_vars[k] = ctx.var[k]

    # Serialize configuration file for test runner
    config = ctx.actions.declare_file("%s.config.js" % ctx.attr.name)
    ctx.actions.write(
        output = config,
        content = """// npm_integration_test runner config generated by npm_integration_test rule
module.exports = {{
    testFiles: [ {TMPL_test_files} ],
    commands: [ {TMPL_commands} ],
    npmPackages: {{ {TMPL_npm_packages} }},
    npmPackageFileFormat: '{TMPL_npm_package_file_format}',
    checkNpmPackages: [ {TMPL_check_npm_packages} ],
    packageJsonRepacements: {{ {TMPL_package_json_replacements} }},
    envVars: {{ {TMPL_env_vars} }},
    debug: {TMPL_debug},
}};
""".format(
            TMPL_test_files = ", ".join(["'%s'" % _to_manifest_path(ctx, f) for f in ctx.files.test_files]),
            TMPL_commands = ", ".join(["'%s'" % s for s in commands]),
            TMPL_npm_packages = ", ".join(["'%s': [%s]" % (ctx.attr.npm_packages[n], ", ".join(["'%s'" % _to_manifest_path(ctx, f) for f in n.files.to_list()])) for n in ctx.attr.npm_packages]),
            TMPL_npm_package_file_format = ctx.attr.npm_package_file_format,
            TMPL_check_npm_packages = ", ".join(["'%s'" % s for s in ctx.attr.check_npm_packages]),
            TMPL_package_json_replacements = ", ".join(["'%s': '%s'" % (f, ctx.attr.package_json_replacements[f]) for f in ctx.attr.package_json_replacements]),
            TMPL_env_vars = ", ".join(["'%s': '%s'" % (k, env_vars[k]) for k in env_vars]),
            TMPL_debug = "true" if ctx.attr.debug else "false",
        ),
    )

    if is_windows(ctx):
        launcher_content = """@echo off
SETLOCAL ENABLEEXTENSIONS
SETLOCAL ENABLEDELAYEDEXPANSION
{rlocation_function}
call :rlocation {TMPL_test_runner} TEST_RUNNER
call :rlocation {TMPL_args} ARGS
%TEST_RUNNER% %ARGS% %*
        """.format(
            TMPL_test_runner = _to_manifest_path(ctx, ctx.executable._test_runner),
            TMPL_args = _to_manifest_path(ctx, config),
            rlocation_function = BATCH_RLOCATION_FUNCTION,
        )
        executable = ctx.actions.declare_file(ctx.attr.name + ".bat")
    else:
        launcher_content = """#!/usr/bin/env bash
# Immediately exit if any command fails.
set -e

if [ -e "$RUNFILES_MANIFEST_FILE" ]; then
  while read line; do
    declare -a PARTS=($line)
    if [ "${{PARTS[0]}}" == "{TMPL_test_runner}" ]; then
      readonly TEST_RUNNER=${{PARTS[1]}}
    elif [ "${{PARTS[0]}}" == "{TMPL_args}" ]; then
      readonly ARGS=${{PARTS[1]}}
    fi
  done < $RUNFILES_MANIFEST_FILE
else
  readonly TEST_RUNNER=../{TMPL_test_runner}
  readonly ARGS={TMPL_args}
fi

$TEST_RUNNER $ARGS "$@"
        """.format(
            TMPL_test_runner = _to_manifest_path(ctx, ctx.executable._test_runner),
            TMPL_args = _to_manifest_path(ctx, config),
        )
        executable = ctx.actions.declare_file(ctx.attr.name + ".sh")

    # Test executable is a shell script on Linux and macOS and a Batch script on Windows,
    # which runs ctx.executable._test_runner and passes it the generated configuration file
    ctx.actions.write(
        output = executable,
        is_executable = True,
        content = launcher_content,
    )

    runfiles = [config] + ctx.files.test_files + ctx.files.npm_packages + ctx.files.data

    return [DefaultInfo(
        runfiles = ctx.runfiles(files = runfiles).merge(ctx.attr._test_runner[DefaultInfo].data_runfiles),
        executable = executable,
    )]

NPM_INTEGRATION_TEST_ATTRS = {
    "commands": attr.string_list(
        default = [],
        mandatory = True,
        doc = """The list of test commands to run. Defaults to `[]`.""",
    ),
    "configuration_env_vars": attr.string_list(
        doc = """Pass these configuration environment variables to the resulting test.
        Chooses a subset of the configuration environment variables (taken from `ctx.var`), which also
        includes anything specified via the --define flag.
        Note, this can lead to different results for the test.""",
        default = [],
    ),
    "check_npm_packages": attr.string_list(
        doc = """A list of npm packages that should be replaced in this test.

This attribute checks that none of the npm packages lists is found in the workspace-under-test's
package.json file unlinked to a generated npm package.

This can be used to verify that all npm package artifacts that need to be tested against are indeed
replaced in all integration tests. For example,
```
check_npm_packages = [
    "@angular/common",
    "@angular/compiler",
    "@angular/compiler-cli",
    "@angular/core",
],
```
If an `npm_packages` replacement on any package listed is missed then the test will fail. Since listing all
npm packages in `npm_packages` is expensive as any change will result in all integration tests re-running,
this attribute allows a fine grained `npm_packages` per integration test with the added safety that none
are missed for any one test.
""",
    ),
    "data": attr.label_list(
        doc = """Data dependencies for test.""",
        allow_files = True,
    ),
    "debug": attr.bool(
        doc = """Setup the test for debugging.

If set to true then the package.json replacement are done in-place instead of a tmp folder
and the test is not run. This is used to configure the test folder for local testing and debugging.
""",
        default = False,
    ),
    "npm_packages": attr.label_keyed_string_dict(
        doc = """A label keyed string dictionary of npm package replacements to make in the workspace-under-test's
package.json with generated npm package targets. The targets should be npm_package rules.

For example,
```
npm_packages = {
    "//packages/common:npm_package": "@angular/common",
    "//packages/compiler:npm_package": "@angular/compiler",
    "//packages/compiler-cli:npm_package": "@angular/compiler-cli",
    "//packages/core:npm_package": "@angular/core",
}
```""",
        allow_files = True,
    ),
    "package_json_replacements": attr.string_dict(
        doc = """A string dictionary of other package.json package replacements to make.

This can be used for integration testing against multiple external npm dependencies without duplicating code. For example,
```
[npm_integration_test(
    name = "integration_foobar_%s" % tsc_version.replace(".", "_"),
    ...
    package_json_replacements = {
        "typescript": tsc_version,
    },
    ...
) for tsc_version in [
    "2.7.x",
    "2.8.x",
    "2.9.x",
    "3.0.x",
    "3.1.x",
    "3.2.x",
    "3.3.x",
    "3.4.x",
    "3.5.x",
]]```""",
    ),
    "npm_package_file_format": attr.string(
        doc = """Controls how npm_packages are referenced in the test's package.json file.

tgz - npm_packages are archived into a `.tgz` file in a tmp folder. The reference in the modified package.json
      `"pkg_name": "file:/path/to/tmp/pkg.tgz"`. GZip compression level is set to zero. This is the recommended file
      format that works with both yarn and npm.
tar - npm_packages are archived into a `.tar` file in a tmp folder. The reference in the modified package.json
      `"pkg_name": "file:/path/to/tmp/pkg.tar"`. This format works with npm but not all versions of yarn can handle
      extracting a tar file.
directory - npm_packages are copied to a tmp folder and referenced as a directory. The reference in the modified package.json
      `"pkg_name": "file:/path/to/tmp"`. This format works with yarn but npm may have issues as by default (since npm 5)
      directory `file:` references are symlinked instead of copied which leads to file permissions issues with npm install.
      For more details on npm 5's symlinking behavior when installing a package directory see the list of Breaking Changes in the
      npm v5.0.0 release blog post https://blog.npmjs.org/post/161081169345/v500. The PR that makes the change is
      https://github.com/npm/npm/pull/15900. The following blog post also touches on the subject
      https://medium.com/@alex_young/npm-5-and-file-urls-3c3631f7367c.

Defaults to 'tgz' which works with both yarn and npm.
""",
        values = ["tgz", "tar", "directory"],
        default = "tgz",
    ),
    "test_files": attr.label(
        doc = """A filegroup of all files necessary to run the test.""",
    ),
    "_test_runner": attr.label(
        executable = True,
        cfg = "host",
        default = Label("@angular//tools/npm_integration_test:test_runner"),
    ),
}

_npm_integration_test = rule(
    implementation = _npm_integration_test_impl,
    doc = """Runs an integration test.""",
    attrs = NPM_INTEGRATION_TEST_ATTRS,
    test = True,
)

def npm_integration_test(name, **kwargs):
    _npm_integration_test(
        name = name,
        **kwargs
    )

    # Setup a .debug target that sets the debug attribute to True.
    # This target must be run with `bazel run` so it is tagged manual.
    _npm_integration_test(
        name = name + ".debug",
        debug = True,
        tags = kwargs.pop("tags", []) + ["manual"],
        **kwargs
    )

def angular_integration_test(**kwargs):
    "Set defaults for the npm_integration_test common to the angular repo"
    GENERATED_NPM_PACKAGES = [
        "@angular/animations",
        "@angular/bazel",
        "@angular/benchpress",
        "@angular/common",
        "@angular/compiler",
        "@angular/compiler-cli",
        "@angular/core",
        "@angular/elements",
        "@angular/forms",
        "@angular/http",
        "@angular/language-service",
        "@angular/platform-browser",
        "@angular/platform-browser-dynamic",
        "@angular/platform-server",
        "@angular/platform-webworkeer",
        "@angular/platform-webworker-dynamic",
        "@angular/router",
        "@angular/service-worker",
        "@angular/upgrade",
        "zone.js",
    ]
    npm_integration_test(
        check_npm_packages = GENERATED_NPM_PACKAGES,
        # Integration do not work inside of a sandbox as they may run host applications such
        # as chrome (which is run by ng) that require access to files outside of the sandbox.
        # They also need to run locally and not on RBE as they require network access for
        # yarn install & npm install.
        tags = kwargs.pop("tags", []) + ["no-sandbox", "local"],
        **kwargs
    )
