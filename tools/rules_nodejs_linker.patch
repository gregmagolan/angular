diff --git a/internal/linker/index.js b/internal/linker/index.js
index 02bbfc82..fa967ab0 100644
--- a/internal/linker/index.js
+++ b/internal/linker/index.js
@@ -47,16 +47,33 @@ Include as much of the build output as you can without disclosing anything confi
     function mkdirp(p) {
         if (!fs.existsSync(p)) {
             mkdirp(path.dirname(p));
-            fs.mkdirSync(p);
+            log_verbose(`mkdir( ${p} )`);
+            try {
+                fs.mkdirSync(p);
+            }
+            catch (e) {
+                if (e.code !== 'EEXIST') {
+                    // can happen if path being created exists via a symlink
+                    throw e;
+                }
+            }
         }
     }
     function symlink(target, path) {
         return __awaiter(this, void 0, void 0, function* () {
             log_verbose(`symlink( ${path} -> ${target} )`);
+            if (!fs.existsSync(target)) {
+                // This can happen if a module mapping is propogated from a dependency
+                // but the targat that generated the mapping in not in the deps. We want
+                // to avoid creating a symlink to a non-existant target as this will
+                // break any nested symlinks that may be created after this.
+                return false;
+            }
             // Use junction on Windows since symlinks require elevated permissions.
             // We only link to directories so junctions work for us.
             try {
                 yield fs.promises.symlink(target, path, 'junction');
+                return true;
             }
             catch (e) {
                 if (e.code !== 'EEXIST') {
@@ -75,6 +92,7 @@ Include as much of the build output as you can without disclosing anything confi
                         `\n  pwd ${process.cwd()}\n  target ${target}\n  path ${path}\n***`);
                 }
             }
+            return false;
         });
     }
     /**
@@ -101,7 +119,7 @@ Include as much of the build output as you can without disclosing anything confi
         // Account for Bazel --legacy_external_runfiles
         // which look like 'my_wksp/external/npm/node_modules'
         if (fs.existsSync(path.join('external', root))) {
-            log_verbose('Found legacy_external_runfiles, switching root to', path.join('external', root));
+            log_verbose('found legacy_external_runfiles, switching root to', path.join('external', root));
             return path.join('external', root);
         }
         // The repository should be layed out in the parent directory
@@ -227,6 +245,7 @@ Include as much of the build output as you can without disclosing anything confi
             log_verbose(`module manifest: workspace ${workspace}, bin ${bin}, root ${root} with first-party packages\n`, modules);
             const rootDir = resolveRoot(root, runfiles);
             log_verbose('resolved root', root, 'to', rootDir);
+            log_verbose('cwd', process.cwd());
             // Bazel starts actions with pwd=execroot/my_wksp
             const workspaceDir = path.resolve('.');
             // Convert from runfiles path
@@ -250,33 +269,66 @@ Include as much of the build output as you can without disclosing anything confi
             const workspaceAbs = path.resolve(workspaceDir);
             // Now add symlinks to each of our first-party packages so they appear under the node_modules tree
             const links = [];
-            const linkModule = (name, root, modulePath) => __awaiter(this, void 0, void 0, function* () {
-                let target = '<package linking failed>';
-                switch (root) {
-                    case 'bin':
-                        // FIXME(#1196)
-                        target = path.join(workspaceAbs, bin, toWorkspaceDir(modulePath));
-                        break;
-                    case 'src':
-                        target = path.join(workspaceAbs, toWorkspaceDir(modulePath));
-                        break;
-                    case 'runfiles':
-                        target = runfiles.resolve(modulePath) || '<runfiles resolution failed>';
-                        break;
+            const linkModules = (modules) => __awaiter(this, void 0, void 0, function* () {
+                for (const m of modules) {
+                    let target = '<package linking failed>';
+                    switch (m.root) {
+                        case 'bin':
+                            // FIXME(#1196)
+                            target = path.join(workspaceAbs, bin, toWorkspaceDir(m.modulePath));
+                            break;
+                        case 'src':
+                            target = path.join(workspaceAbs, toWorkspaceDir(m.modulePath));
+                            break;
+                        case 'runfiles':
+                            target = runfiles.resolve(m.modulePath) || '<runfiles resolution failed>';
+                            break;
+                    }
+                    // ensure the subdirectories exist
+                    mkdirp(path.dirname(m.name));
+                    yield symlink(target, m.name);
                 }
-                yield symlink(target, name);
             });
-            for (const m of Object.keys(modules)) {
-                const segments = m.split('/');
-                if (segments.length > 2) {
-                    throw new Error(`module ${m} has more than 2 segments which is not a valid node module name`);
+            // Group nested modules as these need to be symlinked in order.
+            // For example, given a list of module keys such as:
+            // ['a', '@foo/c/c/c/c', 'b/b', 'b', '@foo/c', '@foo/c/c']
+            // this reducer should output the groups list:
+            // [ [ '@foo/c', '@foo/c/c', '@foo/c/c/c/c' ], [ 'a' ], [ 'b', 'b/b' ] ]
+            const groupedModules = Object.keys(modules).sort().reduce((grouped, module, index, array) => {
+                if (index > 0 && module.startsWith(`${array[index - 1]}/`)) {
+                    grouped[grouped.length - 1].push(module);
                 }
-                if (segments.length == 2) {
-                    // ensure the scope exists
-                    mkdirp(segments[0]);
+                else {
+                    grouped.push([module]);
                 }
-                const [kind, modulePath] = modules[m];
-                links.push(linkModule(m, kind, modulePath));
+                return grouped;
+            }, []);
+            log_verbose(`grouped modules ${JSON.stringify(groupedModules)}`);
+            for (const group of groupedModules) {
+                // reduce links such as `@foo/b/c => /path/to/a/b/c` to their
+                // lowest common denominator `@foo => /path/to/a`
+                const mappings = group.map(name => {
+                    let [kind, modulePath] = modules[name];
+                    for (;;) {
+                        const bn = path.basename(name);
+                        const bmp = path.basename(modulePath);
+                        if (bn == bmp && bn !== name && bmp !== modulePath) {
+                            // strip off the last segment as it is common
+                            name = path.dirname(name);
+                            modulePath = path.dirname(modulePath);
+                            log_verbose(`module mapping ( ${name}/${bn} => ${modulePath}/${bmp} ) reduced to ( ${name} => ${modulePath} )`);
+                        }
+                        else {
+                            break;
+                        }
+                    }
+                    return { name: name, root: kind, modulePath };
+                });
+                // synchronously ensure that common directories between groups
+                // exist to prevent race conditions
+                mkdirp(path.dirname(mappings[0].name));
+                // call linkModules for each group
+                links.push(linkModules(mappings));
             }
             let code = 0;
             yield Promise.all(links).catch(e => {
